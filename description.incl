<h2>Description</h2>
<p>
This is a implementation of the JSON specification according to 
<a href="http://www.ietf.org/rfc/rfc4627.txt">RFC 4627</a>. You can think of it as a low fat
alternative to XML, if you want to store data to disk or transmit it over a
network rather than use a verbose markup language.
</p>
<p>
Starting from version 1.0.0 on there
will be two variants available:
</p>
<ul>
<li>A pure ruby variant, that relies on the iconv and the stringscan
  extensions, which are both part of the ruby standard library.</li>
<li> The quite a bit faster (see the <a href="doc/index.html">documentation</a>) C
  extension variant, which is in parts implemented in C and comes with its own
  unicode conversion functions and a parser
  generated by the <a href="http://www.cs.queensu.ca/~thurston/ragel">Ragel
  State Machine Compiler</a>.</li>
</ul>
<p>
Both variants of the JSON generator escape all non-ASCII an control
characters with \uXXXX escape sequences, and support UTF-16 surrogate pairs
in order to be able to generate the whole range of unicode code points. This
means that generated JSON text is encoded as UTF-8 (because ASCII is a subset
of UTF-8) and at the same time avoids decoding problems for receiving
endpoints, that don't expect UTF-8 encoded texts. On the negative side this
may lead to a bit longer strings than necessarry.
</p>
<p>
It's also easy to extend JSON data types for arbitrary Ruby classes (including
your own) like this:
</p>
<pre>
class Range
  def to_json(*a)
    {
      'json_class'   => self.class.name,
      'data'         => \[ first, last, exclude_end? ]
    }.to_json(*a)
  end

  def self.json_create(o)
    new(*o\['data'])
  end
end
</pre>
<p>
Now Range instances can be serialized/deserialized:
</p>
<pre>
JSON.parse((1..10).to_json) == (1..10)
</pre>
<p>
A lot of additional information about JSON can be found <a
href="http://www.json.org/">Douglas Crockford's JSON
site</a>.
</p>
